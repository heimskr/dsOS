#pragma once

#include "cstddef"

// Based on code from the LLVM project (https://llvm.org).

#define _INLINE inline __attribute__((__always_inline__))

#ifndef __has_feature
#define __has_feature(__x) 0
#endif

namespace std {
	template <typename T1, typename T2>
	struct pair;

	struct __two {
		char __lx[2];
	};

	template <typename T>
	T && __declval(int);
	template <typename T>
	T __declval(long);
	template <typename T>
	decltype(std::__declval<T>(0)) declval() noexcept;

	template <typename T, T v>
	struct integral_constant {
		static constexpr const T value = v;
		typedef T value_type;
		typedef integral_constant type;
		
		constexpr operator value_type() const noexcept {
			return value;
		}

		constexpr value_type operator()() const noexcept {
			return value;
		}
	};

	typedef integral_constant<bool, true> true_type;
	typedef integral_constant<bool, false> false_type;

	template <bool B>
	using bool_constant = integral_constant<bool, B>;

	template <typename T>
	struct remove_const {
		typedef T type;
	};

	template <typename T>
	struct remove_const<const T> {
		typedef T type;
	};

	template <typename T>
	using remove_const_t = typename remove_const<T>::type;

	template <typename T>
	struct remove_volatile {
		typedef T type;
	};

	template<typename T>
	struct remove_volatile<volatile T> {
		typedef T type;
	};

	template <typename T>
	using remove_volatile_t = typename remove_volatile<T>::type;

	template <typename T>
	struct remove_cv {
		typedef typename remove_volatile<typename remove_const<T>::type>::type type;
	};

	template <typename T>
	using remove_cv_t = typename remove_cv<T>::type;

	template <typename T>
	struct __libcpp_is_final: public integral_constant<bool, __is_final(T)> {};
	template <typename T>
	struct is_final: public integral_constant<bool, __is_final(T)> {};
	template <typename T>
	constexpr bool is_final_v = is_final<T>::value;

	template <typename T>
	struct is_empty: public integral_constant<bool, __is_empty(T)> {};
	template <typename T>
	constexpr bool is_empty_v = is_empty<T>::value;

	template <bool, typename T = void>
	struct enable_if {};
	template <typename T>
	struct enable_if<true, T> {
		typedef T type;
	};
	template <bool B, typename T = void>
	using enable_if_t = typename enable_if<B, T>::type;

	template <typename T, typename U>
	struct is_same: public false_type {};
	template <typename T>
	struct is_same<T, T>: public true_type {};

	template <typename T>
	struct is_array: public false_type {};
	template <typename T>
	struct is_array<T[]>: public true_type {};
	template <typename T, size_t N>
	struct is_array<T[N]>: public true_type {};

	template <typename T>
	struct is_lvalue_reference: public false_type {};
	template <typename T>
	struct is_lvalue_reference<T &>: public true_type {};

	template <typename T>
	struct is_rvalue_reference: public false_type {};
	template <typename T>
	struct is_rvalue_reference<T &&>: public true_type {};

	template <typename T>
	struct is_reference: public false_type {};
	template <typename T>
	struct is_reference<T &>: public true_type {};
	template <typename T>
	struct is_reference<T &&>: public true_type {};

	template <typename T>
	inline constexpr bool is_reference_v = is_reference<T>::value;
	template <typename T>
	inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
	template <typename T>
	inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

	template <typename T>
	struct is_const: public false_type {};
	template <typename T>
	struct is_const<T const>: public true_type {};
	template <typename T>
	inline constexpr bool is_const_v = is_const<T>::value;

	template <typename T>
	struct is_volatile: public false_type {};
	template <typename T>
	struct is_volatile<T volatile>: public true_type {};
	template <typename T>
	inline constexpr bool is_volatile_v = is_volatile<T>::value;

	// is_union

	template <class _Tp>
	struct is_union: public integral_constant<bool, __is_union(_Tp)> {};

	template <class _Tp>
	constexpr bool is_union_v = is_union<_Tp>::value;

	// is_class

	template <class _Tp>
	struct is_class: public integral_constant<bool, __is_class(_Tp)> {};

	template <class _Tp>
	constexpr bool is_class_v = is_class<_Tp>::value;

	// is_function

	template <typename T>
	struct is_function: public bool_constant<!(is_reference_v<T> || is_const_v<const T>)> {};

	template <class T>
	constexpr bool is_function_v = is_function<T>::value;

	// is_integral

	template <typename T>
	struct __libcpp_is_integral                    : public false_type {};
	template <>           struct __libcpp_is_integral<bool>              : public true_type {};
	template <>           struct __libcpp_is_integral<char>              : public true_type {};
	template <>           struct __libcpp_is_integral<signed char>       : public true_type {};
	template <>           struct __libcpp_is_integral<unsigned char>     : public true_type {};
	template <>           struct __libcpp_is_integral<wchar_t>           : public true_type {};
	template <>           struct __libcpp_is_integral<char16_t>          : public true_type {};
	template <>           struct __libcpp_is_integral<char32_t>          : public true_type {};
	template <>           struct __libcpp_is_integral<short>             : public true_type {};
	template <>           struct __libcpp_is_integral<unsigned short>    : public true_type {};
	template <>           struct __libcpp_is_integral<int>               : public true_type {};
	template <>           struct __libcpp_is_integral<unsigned int>      : public true_type {};
	template <>           struct __libcpp_is_integral<long>              : public true_type {};
	template <>           struct __libcpp_is_integral<unsigned long>     : public true_type {};
	template <>           struct __libcpp_is_integral<long long>         : public true_type {};
	template <>           struct __libcpp_is_integral<unsigned long long>: public true_type {};
	template <>           struct __libcpp_is_integral<__int128_t>        : public true_type {};
	template <>           struct __libcpp_is_integral<__uint128_t>       : public true_type {};

	template <typename T>
	struct is_integral: public __libcpp_is_integral<typename remove_cv<T>::type> {};

	template <typename T>
	constexpr bool is_integral_v = is_integral<T>::value;

	template <class T>
	struct __libcpp_is_member_pointer {
		enum {
			__is_member = false,
			__is_func = false,
			__is_obj = false
		};
	};

	template <class T, class U>
	struct __libcpp_is_member_pointer<T U::*> {
		enum {
			__is_member = true,
			__is_func = is_function<T>::value,
			__is_obj = !__is_func,
		};
	};


	template <class T>
	struct is_member_function_pointer: public bool_constant<__libcpp_is_member_pointer<typename remove_cv<T>::type>::__is_func> {};

	template <class T>
	constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;

	// is_member_pointer

	template <class T>
	struct is_member_pointer: public bool_constant<__libcpp_is_member_pointer<typename remove_cv<T>::type>::__is_member > {};

	template <class T>
	constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

	// is_member_object_pointer

	template <class T>
	struct is_member_object_pointer: public bool_constant<__libcpp_is_member_pointer<typename remove_cv<T>::type>::__is_obj>  {};

	template <class T>
	constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;

	// is_enum

	template <class T>
	struct is_enum: public integral_constant<bool, __is_enum(T)> {};

	template <class T>
	constexpr bool is_enum_v = is_enum<T>::value;

	// is_floating_point

	template <typename T>
	struct __libcpp_is_floating_point             : public false_type {};
	template <>           struct __libcpp_is_floating_point<float>      : public true_type {};
	template <>           struct __libcpp_is_floating_point<double>     : public true_type {};
	template <>           struct __libcpp_is_floating_point<long double>: public true_type {};

	template <typename T>
	struct is_floating_point: public __libcpp_is_floating_point<typename remove_cv<T>::type> {};

	template <typename T>
	constexpr bool is_floating_point_v = is_floating_point<T>::value;

	// is_arithmetic

	template <class T>
	struct is_arithmetic: public integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

	template <class T>
	constexpr bool is_arithmetic_v = is_arithmetic<T>::value;

	// is_void

	template <typename T>
	struct __libcpp_is_void: public false_type {};

	template <>
	struct __libcpp_is_void<void>: public true_type {};

	template <typename T>
	struct is_void: public __libcpp_is_void<typename remove_cv<T>::type> {};

	template <typename T>
	constexpr bool is_void_v = is_void<T>::value;

	// __is_nullptr_t

	template <typename T>
	struct __is_nullptr_t_impl: public false_type {};
	template <>
	struct __is_nullptr_t_impl<nullptr_t>: public true_type {};

	template <typename T>
	struct __is_nullptr_t: public __is_nullptr_t_impl<typename remove_cv<T>::type> {};

	template <typename T>
	struct is_null_pointer: public __is_nullptr_t_impl<typename remove_cv<T>::type> {};

	template <typename T>
	constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

	// is_fundamental

	template <class T>
	struct is_fundamental: public integral_constant<bool, is_void<T>::value || __is_nullptr_t<T>::value || is_arithmetic<T>::value> {};

	template <class T>
	constexpr bool is_fundamental_v = is_fundamental<T>::value;

	// is_pointer

	template <typename T>
	struct __libcpp_is_pointer: public false_type {};

	template <typename T>
	struct __libcpp_is_pointer<T *>: public true_type {};

	template <typename T>
	struct __libcpp_remove_objc_qualifiers {
		typedef T type;
	};

	template <typename T>
	struct is_pointer: public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<T>::type>::type> {};

	template <typename T>
	constexpr bool is_pointer_v = is_pointer<T>::value;

	// is_scalar

	template <class T>
	struct is_scalar: public integral_constant<bool, is_arithmetic<T>::value || is_member_pointer<T>::value || is_pointer<T>::value || __is_nullptr_t<T>::value || is_enum<T>::value> {};

	template <>
	struct is_scalar<nullptr_t>: public true_type {};

	template <class T>
	constexpr bool is_scalar_v = is_scalar<T>::value;

	// is_object

	template <class T>
	struct is_object: public integral_constant<bool, is_scalar<T>::value || is_array<T>::value || is_union<T>::value || is_class<T>::value> {};

	template <class T>
	constexpr bool is_object_v = is_object<T>::value;

	// is_compound

	template <class T>
	struct is_compound: public integral_constant<bool, !is_fundamental<T>::value> {};

	template <class T>
	constexpr bool is_compound_v = is_compound<T>::value;

	//

	template <typename T, typename U>
	using _IsSame = bool_constant<is_same<T, U>::value>;

	template <typename T, typename U>
	using _IsNotSame = bool_constant<!is_same<T, U>::value>;

	// __is_referenceable  [defns.referenceable]

	struct __is_referenceable_impl {
		template <class T> static T & __test(int);
		template <class T> static __two __test(...);
	};

	template <class T>
	struct __is_referenceable: integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<T>(0)), __two>::value> {};

	template <typename B, typename D>
	struct is_base_of: public integral_constant<bool, __is_base_of(B, D)> {};

	// remove_all_extents

	template <typename T>
	struct remove_all_extents {
		typedef T type;
	};
	template <typename T>
	struct remove_all_extents<T[]> {
		typedef typename remove_all_extents<T>::type type;
	};
	template <typename T, size_t N>
	struct remove_all_extents<T[N]> {
		typedef typename remove_all_extents<T>::type type;
	};

	template <typename T>
	using remove_all_extents_t = typename remove_all_extents<T>::type;

	template <typename>
	struct __is_destructible_apply {
		typedef int type;
	};

	template <typename T>
	struct __is_destructor_wellformed {
		template <typename T1>
		static char __test(typename __is_destructible_apply<decltype(std::declval<T1 &>().~T1())>::type);

		template <typename T1>
		static __two __test(...);

		static const bool value = sizeof(__test<T>(12)) == sizeof(char);
	};

	template <typename T, bool>
	struct __destructible_imp;

	template <typename T>
	struct __destructible_imp<T, false>:
		public std::integral_constant<bool, __is_destructor_wellformed<typename std::remove_all_extents<T>::type>::value> {};

	template <typename T>
	struct __destructible_imp<T, true>: public std::true_type {};

	template <typename T, bool>
	struct __destructible_false;

	template <typename T>
	struct __destructible_false<T, false>: public __destructible_imp<T, std::is_reference<T>::value> {};

	template <typename T>
	struct __destructible_false<T, true>: public std::false_type {};

	template <typename T>
	struct is_destructible: public __destructible_false<T, std::is_function<T>::value> {};

	template <typename T>
	struct is_destructible<T[]>: public std::false_type {};

	template <>
	struct is_destructible<void>: public std::false_type {};















	template <typename T>
	constexpr bool is_destructible_v = is_destructible<T>::value;

	template <typename T>
	struct remove_reference {
		typedef T type;
	};

	template <typename T>
	struct remove_reference<T &> {
		typedef T type;
	};

	template <typename T>
	struct remove_reference<T &&> {
		typedef T type;
	};


	// remove_extent

	template <typename T>
	struct remove_extent {
		typedef T type;
	};

	template <typename T>
	struct remove_extent<T[]> {
		typedef T type;
	};

	template <typename T, size_t N>
	struct remove_extent<T[N]> {
		typedef T type;
	};

	template <typename T> using remove_extent_t = typename remove_extent<T>::type;

	template <typename T>
	struct __uncvref {
		typedef typename remove_cv<typename remove_reference<T>::type>::type type;
	};

	template <typename T>
	using __uncvref_t = typename __uncvref<T>::type;

	template <typename T>
	struct __unconstref {
		typedef typename remove_const<typename remove_reference<T>::type>::type type;
	};

	// add_pointer

	template <typename T, bool = __is_referenceable<T>::value || _IsSame<typename remove_cv<T>::type, void>::value>
	struct __add_pointer_impl {
		typedef typename remove_reference<T>::type * type;
	};

	template <typename T>
	struct __add_pointer_impl<T, false> {
		typedef T type;
	};

	template <typename T>
	struct add_pointer {
		typedef typename __add_pointer_impl<T>::type type;
	};

	// type_identity

	template<typename T>
	struct type_identity {
		typedef T type;
	};

	template<typename T>
	using type_identity_t = typename type_identity<T>::type;

	// is_signed

	template <typename T, bool = is_integral<T>::value>
	struct __libcpp_is_signed_impl : public integral_constant<bool, T(-1) < T(0)> {};

	template <typename T>
	struct __libcpp_is_signed_impl<T, false> : public true_type {};  // floating point

	template <typename T, bool = is_arithmetic<T>::value>
	struct __libcpp_is_signed : public __libcpp_is_signed_impl<T> {};

	template <typename T>
	struct __libcpp_is_signed<T, false> : public false_type {};

	template <typename T>
	struct is_signed : public __libcpp_is_signed<T> {};

	#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
	template <typename T>
	constexpr bool is_signed_v = is_signed<T>::value;
	#endif

	// is_unsigned

	template <typename T, bool = is_integral<T>::value>
	struct __libcpp_is_unsigned_impl : public bool_constant<T(0) < T(-1)> {};

	template <typename T>
	struct __libcpp_is_unsigned_impl<T, false> : public false_type {};  // floating point

	template <typename T, bool = is_arithmetic<T>::value>
	struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<T> {};

	template <typename T>
	struct __libcpp_is_unsigned<T, false> : public false_type {};

	template <typename T>
	struct is_unsigned : public __libcpp_is_unsigned<T> {};

	#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
	template <typename T>
	constexpr bool is_unsigned_v = is_unsigned<T>::value;
	#endif

	// rank

	template <typename T>
	struct rank
		: public integral_constant<size_t, 0> {};
	template <typename T>
	struct rank<T[]>
		: public integral_constant<size_t, rank<T>::value + 1> {};
	template <typename T, size_t _Np>
	struct rank<T[_Np]>
		: public integral_constant<size_t, rank<T>::value + 1> {};

	#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
	template <typename T>
	constexpr size_t rank_v = rank<T>::value;
	#endif

	// extent

	template <typename T, unsigned _Ip = 0>
	struct extent
		: public integral_constant<size_t, 0> {};
	template <typename T>
	struct extent<T[], 0>
		: public integral_constant<size_t, 0> {};
	template <typename T, unsigned _Ip>
	struct extent<T[], _Ip>
		: public integral_constant<size_t, extent<T, _Ip-1>::value> {};
	template <typename T, size_t _Np>
	struct extent<T[_Np], 0>
		: public integral_constant<size_t, _Np> {};
	template <typename T, size_t _Np, unsigned _Ip>
	struct extent<T[_Np], _Ip>
		: public integral_constant<size_t, extent<T, _Ip-1>::value> {};

	#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
	template <typename T, unsigned _Ip = 0>
	constexpr size_t extent_v = extent<T, _Ip>::value;
	#endif





	// add_const

	template <typename T>
	struct add_const {
		typedef const T type;
	};
	template <typename T>
	using add_const_t = typename add_const<T>::type;

	template <typename T, bool = __is_referenceable<T>::value>
	struct __add_lvalue_reference_impl {
		typedef T  type;
	};

	template <typename T>
	struct __add_lvalue_reference_impl<T, true> {
		typedef T & type;
	};

	template <typename T>
	struct add_lvalue_reference {
		typedef typename __add_lvalue_reference_impl<T>::type type;
	};

	template <typename T>
	using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

	template <typename T, bool = __is_referenceable<T>::value>
	struct __add_rvalue_reference_impl {
		typedef T type;
	};
	template <typename T>
	struct __add_rvalue_reference_impl<T, true> {
		typedef T && type;
	};

	template <typename T>
	struct add_rvalue_reference {
		typedef typename __add_rvalue_reference_impl<T>::type type;};

	template <typename T>
	using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

	template <typename T>
	struct add_volatile {
		typedef volatile T type;
	};
	template <typename T>
	using add_volatile_t = typename add_volatile<T>::type;

	template <typename T>
	struct add_cv {
		typedef const volatile T type;
	};
	template <typename T>
	using add_cv_t = typename add_cv<T>::type;

	template <typename, typename T>
	struct __select_2nd {
		typedef T type;
	};

	template <typename T, typename Arg>
	typename __select_2nd<decltype((std::declval<T>() = std::declval<Arg>())), true_type>::type
	__is_assignable_test(int);

	template <typename, typename>
	false_type __is_assignable_test(...);

	template <typename T, typename Arg, bool = is_void<T>::value || is_void<Arg>::value>
	struct __is_assignable_imp: public decltype((std::__is_assignable_test<T, Arg>(0))) {};

	template <typename T, typename Arg>
	struct __is_assignable_imp<T, Arg, true>: public false_type {};

	template <typename T, typename Arg>
	struct is_assignable: public __is_assignable_imp<T, Arg> {};

	template <typename T, typename Arg>
	constexpr bool is_assignable_v = is_assignable<T, Arg>::value;

	template <typename T>
	struct is_copy_assignable: public is_assignable<typename add_lvalue_reference<T>::type, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

	template <typename T>
	constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;

	template <typename T>
	struct is_move_assignable: public is_assignable<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_move_assignable_v = is_move_assignable<T>::value;

	template <bool>
	struct _MetaBase;

	template <>
	struct _MetaBase<true> {
		template <typename T, typename U>
		using _SelectImpl = T;
		template <template <typename...> typename FirstFn, template <typename...> typename, typename... Args>
		using _SelectApplyImpl = FirstFn<Args...>;
		template <typename First, typename...>
		using _FirstImpl = First;
		template <typename, typename Second, typename...>
		using _SecondImpl = Second;
		template <typename T = void>
		using _EnableIfImpl = T;
		template <typename Result, typename First, typename ...Rest>
		using _OrImpl = typename _MetaBase<First::value != true && sizeof...(Rest) != 0>::template _OrImpl<First, Rest...>;
		template <typename Result, typename First, typename ...Rest>
		using _AndImpl = typename _MetaBase<First::value == true && sizeof...(Rest) != 0>::template _AndImpl<First, Rest...>;
	};

	template <>
	struct _MetaBase<false> {
		template <typename T, typename U>
		using _SelectImpl = U;
		template <template <typename...> typename, template <typename...> typename SecondFn, typename ...Args>
		using _SelectApplyImpl = SecondFn<Args...>;
		template <typename Result, typename ...>
		using _OrImpl = Result;
		template <typename Result, typename ...>
		using _AndImpl = Result;
	};

	template<typename Result, typename First, typename... Rest>
	using _AndImpl = typename _MetaBase<First::value == true && sizeof...(Rest) != 0>::template _AndImpl<First, Rest...>;

	template <typename... Rest>
	using _Or = typename _MetaBase<sizeof...(Rest) != 0>::template _OrImpl<false_type, Rest...>;
	template <typename... Rest>
	using _And = typename _MetaBase<sizeof...(Rest) != 0>::template _AndImpl<true_type, Rest...>;
	template <typename Pred>
	struct _Not: bool_constant<!Pred::value> {};

	template <typename T, typename... Args>
	struct __libcpp_is_constructible;

	template <typename To, typename From>
	struct __is_invalid_base_to_derived_cast {
		static_assert(is_reference<To>::value, "Wrong specialization");
		using RawFrom = __uncvref_t<From>;
		using RawTo = __uncvref_t<To>;
		static const bool value = _And<_IsNotSame<RawFrom, RawTo>, is_base_of<RawFrom, RawTo>, _Not<__libcpp_is_constructible<RawTo, From>>>::value;
	};

	template <typename To, typename From>
	struct __is_invalid_lvalue_to_rvalue_cast: false_type {
		static_assert(is_reference<To>::value, "Wrong specialization");
	};

	template <typename ToRef, typename FromRef>
	struct __is_invalid_lvalue_to_rvalue_cast<ToRef &&, FromRef &> {
		using RawFrom = __uncvref_t<FromRef>;
		using RawTo   = __uncvref_t<ToRef>;
		static const bool value = _And<_Not<is_function<RawTo>>, _Or<_IsSame<RawFrom, RawTo>, is_base_of<RawTo, RawFrom>>>::value;
	};

	struct __is_constructible_helper {
		template <typename To>
		static void __eat(To);

		template <typename To, typename From, typename = decltype(__eat<To>(declval<From>()))>
		static true_type __test_cast(int);

		template <typename To, typename From, typename = decltype(static_cast<To>(declval<From>()))>
		static integral_constant<bool,
			!__is_invalid_base_to_derived_cast<To, From>::value && !__is_invalid_lvalue_to_rvalue_cast<To, From>::value>
		__test_cast(long);

		template <typename, typename>
		static false_type __test_cast(...);

		template <typename T, typename... Args, typename = decltype(T(declval<Args>()...))>
		static true_type __test_nary(int);
		template <typename T, typename...>
		static false_type __test_nary(...);

		template <typename T, typename A, typename = decltype(::new T(declval<A>()))>
		static is_destructible<T> __test_unary(int);

		template <typename, typename>
		static false_type __test_unary(...);
	};

	template <typename T, bool = is_void<T>::value>
	struct __is_default_constructible: decltype(__is_constructible_helper::__test_nary<T>(0)) {};

	template <typename T>
	struct __is_default_constructible<T, true>: false_type {};

	template <typename T>
	struct __is_default_constructible<T[], false>: false_type {};

	template <typename T, size_t _Nx>
	struct __is_default_constructible<T[_Nx], false>: __is_default_constructible<typename remove_all_extents<T>::type> {};

	template <typename T, typename... Args>
	struct __libcpp_is_constructible {
		static_assert(1 < sizeof...(Args), "Wrong specialization");
		typedef decltype(__is_constructible_helper::__test_nary<T, Args...>(0)) type;
	};

	template <typename T>
	struct __libcpp_is_constructible<T>: __is_default_constructible<T> {};

	template <typename T, typename A>
	struct __libcpp_is_constructible<T, A>: public decltype(__is_constructible_helper::__test_unary<T, A>(0)) {};

	template <typename T, typename A>
	struct __libcpp_is_constructible<T &, A>: public decltype(__is_constructible_helper::__test_cast<T &, A>(0)) {};

	template <typename T, typename A>
	struct __libcpp_is_constructible<T &&, A>: public decltype(__is_constructible_helper::__test_cast<T &&, A>(0)) {};

	template <typename T, typename... Args>
	struct is_constructible: public __libcpp_is_constructible<T, Args...>::type {};

	template <typename T>
	struct is_default_constructible: public is_constructible<T> {};

	template <typename T>
	constexpr bool is_default_constructible_v = is_default_constructible<T>::value;

	template <typename T>
	void __test_implicit_default_constructible(T);

	template <typename T, typename = void, bool = is_default_constructible<T>::value>
	struct __is_implicitly_default_constructible: false_type {};

	template <typename T>
	struct __is_implicitly_default_constructible<T, decltype(__test_implicit_default_constructible<T const &>({})), true>: true_type {};

	template <typename T>
	struct __is_implicitly_default_constructible<T, decltype(__test_implicit_default_constructible<T const &>({})), false>: false_type {};

	template <typename T>
	struct is_copy_constructible: public is_constructible<T, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

	template <typename T>
	constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;

	template <typename T>
	struct is_move_constructible: public is_constructible<T, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_move_constructible_v = is_move_constructible<T>::value;

//	#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501

	template <typename T, typename... Args>
	struct is_trivially_constructible: integral_constant<bool, __is_trivially_constructible(T, Args...)> {};

/*
	#else  // !__has_feature(is_trivially_constructible)
	template <typename T, typename... Args>
	struct is_trivially_constructible
		: false_type
	{
	};

	template <typename T>
	struct is_trivially_constructible<T>
	#if __has_feature(has_trivial_constructor) || defined(_LIBCPP_COMPILER_GCC)
		: integral_constant<bool, __has_trivial_constructor(T)>
	#else
		: integral_constant<bool, is_scalar<T>::value>
	#endif
	{
	};

	template <typename T>
	struct is_trivially_constructible<T, T&&>
		: integral_constant<bool, is_scalar<T>::value>
	{
	};

	template <typename T>
	struct is_trivially_constructible<T, const T&>
		: integral_constant<bool, is_scalar<T>::value>
	{
	};

	template <typename T>
	struct is_trivially_constructible<T, T&>
		: integral_constant<bool, is_scalar<T>::value>
	{
	};

	#endif  // !__has_feature(is_trivially_constructible)
*/

	template <typename T, typename... Args>
	constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;

	template <typename T>
	struct is_trivially_default_constructible: public is_trivially_constructible<T> {};

	template <typename T>
	constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<T>::value;

	template <typename T>
	struct is_trivially_copy_constructible: public is_trivially_constructible<T, typename add_lvalue_reference<const T>::type> {};

	template <typename T>
	constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;

	template <typename T>
	struct is_trivially_move_constructible: public is_trivially_constructible<T, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;


//	#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501

	template <typename T, typename Arg>
	struct is_trivially_assignable: integral_constant<bool, __is_trivially_assignable(T, Arg)> {};

/*
	#else  // !__has_feature(is_trivially_assignable)

	template <typename T, typename Arg>
	struct is_trivially_assignable
		: public false_type {};

	template <typename T>
	struct is_trivially_assignable<T&, T>
		: integral_constant<bool, is_scalar<T>::value> {};

	template <typename T>
	struct is_trivially_assignable<T&, T&>
		: integral_constant<bool, is_scalar<T>::value> {};

	template <typename T>
	struct is_trivially_assignable<T&, const T&>
		: integral_constant<bool, is_scalar<T>::value> {};

	template <typename T>
	struct is_trivially_assignable<T&, T&&>
		: integral_constant<bool, is_scalar<T>::value> {};

	#endif  // !__has_feature(is_trivially_assignable)
*/

	template <typename T, typename Arg>
	constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, Arg>::value;

	template <typename T>
	struct is_trivially_copy_assignable: public is_trivially_assignable<typename add_lvalue_reference<T>::type, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

	template <typename T>
	constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;

	template <typename T>
	struct is_trivially_move_assignable: public is_trivially_assignable<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;

	template <typename T>
	struct is_trivially_destructible: public integral_constant<bool, is_destructible<T>::value && __has_trivial_destructor(T)> {};

	template <typename T>
	constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;








	template <template <typename...> typename Templ, typename... Args, typename = Templ<Args...>>
	true_type __sfinae_test_impl(int);
	template <template <typename...> typename, typename ...>
	false_type __sfinae_test_impl(...);

	template <template <typename ...> typename Templ, typename... Args>
	using _IsValidExpansion = decltype(std::__sfinae_test_impl<Templ, Args...>(0));

	template <typename>
	struct __void_t {
		typedef void type;
	};

	template <typename T>
	struct __identity {
		typedef T type;
	};

	template <typename T, bool>
	struct __dependent_type: public T {};

	template <bool B, typename If, typename Then>
	struct conditional {
		typedef If type;
	};

	template <typename If, typename Then>
	struct conditional<false, If, Then> {
		typedef Then type;
	};

	template <bool B, typename If, typename Then>
	using conditional_t = typename conditional<B, If, Then>::type;

	template <typename U, bool>
	struct __decay {
		typedef typename remove_cv<U>::type type;
	};

	template <typename U>
	struct __decay<U, true> {
		public:
			typedef typename conditional<is_array<U>::value, typename remove_extent<U>::type *, typename conditional<is_function<U>::value, typename add_pointer<U>::type, typename remove_cv<U>::type>::type>::type type;
	};

	template <typename T>
	struct decay {
		private:
			typedef typename remove_reference<T>::type U;
		
		public:
			typedef typename __decay<U, __is_referenceable<U>::value>::type type;
	};

	template <typename T>
	using decay_t = typename decay<T>::type;



	template <typename T>
	inline constexpr typename remove_reference<T>::type && move(T &&t) noexcept {
		typedef typename remove_reference<T>::type U;
		return static_cast<U &&>(t);
	}

	template <typename T>
	_INLINE constexpr T && forward(typename remove_reference<T>::type &t) noexcept {
		return static_cast<T &&>(t);
	}

	template <typename T>
	_INLINE constexpr T && forward(typename remove_reference<T>::type &&t) noexcept {
		static_assert(!is_lvalue_reference<T>::value, "cannot forward an rvalue as an lvalue");
		return static_cast<T &&>(t);
	}

	namespace __is_construct {
		struct __nat {};
	}

	struct __nat {
		__nat() = delete;
		__nat(const __nat &) = delete;
		__nat & operator=(const __nat &) = delete;
		~__nat() = delete;
	};

	namespace __detail {
		// ALL generic swap overloads MUST already have a declaration available at this point.

		template <typename T, typename U = T, bool _NotVoid = !is_void<T>::value && !is_void<U>::value>
		struct __swappable_with {
			template <typename LHS, typename RHS>
			static decltype(swap(std::declval<LHS>(), std::declval<RHS>())) __test_swap(int);

			template <typename, typename>
			static __nat __test_swap(long);

			// Extra parens are needed for the C++03 definition of decltype.
			typedef decltype((__test_swap<T, U>(0))) __swap1;
			typedef decltype((__test_swap<U, T>(0))) __swap2;

			static const bool value = _IsNotSame<__swap1, __nat>::value
								&& _IsNotSame<__swap2, __nat>::value;
		};

		template <typename T, typename U>
		struct __swappable_with<T, U,  false> : false_type {};

		template <typename T, typename U = T, bool _Swappable = __swappable_with<T, U>::value>
		struct __nothrow_swappable_with {
			static const bool value =
			// #ifndef _LIBCPP_HAS_NO_NOEXCEPT
				noexcept(swap(std::declval<T>(), std::declval<U>())) &&  noexcept(swap(std::declval<U>(), std::declval<T>()));
			// #else
			// 	false;
			// #endif
		};

		template <typename T, typename U>
		struct __nothrow_swappable_with<T, U, false>: false_type {};
	}

	template <typename T>
	struct __is_swappable: public integral_constant<bool, __detail::__swappable_with<T&>::value> {};

	template <typename T>
	struct __is_nothrow_swappable: public integral_constant<bool, __detail::__nothrow_swappable_with<T&>::value> {};

	template <bool, bool, typename T, typename... Args>
	struct __libcpp_is_nothrow_constructible;

	template <typename T, typename... Args>
	struct __libcpp_is_nothrow_constructible</*is constructible*/ true, /*is reference*/ false, T, Args...>: public integral_constant<bool, noexcept(T(declval<Args>()...))> {};

	template <typename T>
	void __implicit_conversion_to(T) noexcept { }

	template <typename T, typename Arg>
	struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, T, Arg>: public integral_constant<bool, noexcept(__implicit_conversion_to<T>(declval<Arg>()))> {};

	template <typename T, bool _IsReference, typename... Args>
	struct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, T, Args...>: public false_type {};

	template <typename T, typename... Args>
	struct is_nothrow_constructible: __libcpp_is_nothrow_constructible<is_constructible<T, Args...>::value, is_reference<T>::value, T, Args...> {};

	template <typename T, size_t _Ns>
	struct is_nothrow_constructible<T[_Ns]>: __libcpp_is_nothrow_constructible<is_constructible<T>::value, is_reference<T>::value, T> {};

	template <typename T, typename ...Args>
	constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;

	template <typename T>
	struct is_nothrow_default_constructible: public is_nothrow_constructible<T> {};

	template <typename T>
	constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<T>::value;

	template <typename T>
	struct is_nothrow_copy_constructible: public is_nothrow_constructible<T, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

	template <typename T>
	constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<T>::value;

	template <typename T>
	struct is_nothrow_move_constructible: public is_nothrow_constructible<T, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;

	template <bool, typename T, typename Arg>
	struct __libcpp_is_nothrow_assignable;

	template <typename T, typename Arg>
	struct __libcpp_is_nothrow_assignable<false, T, Arg>: public false_type {};

	template <typename T, typename Arg>
	struct __libcpp_is_nothrow_assignable<true, T, Arg>: public integral_constant<bool, noexcept(std::declval<T>() = std::declval<Arg>())> {};

	template <typename T, typename Arg>
	struct is_nothrow_assignable: public __libcpp_is_nothrow_assignable<is_assignable<T, Arg>::value, T, Arg> {};

	template <typename T, typename Arg>
	constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, Arg>::value;

	template <typename T>
	struct is_nothrow_copy_assignable: public is_nothrow_assignable<typename add_lvalue_reference<T>::type, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

	template <typename T>
	constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;

	template <typename T>
	struct is_nothrow_move_assignable: public is_nothrow_assignable<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

	template <typename T>
	constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;

	template <bool, typename T>
	struct __libcpp_is_nothrow_destructible;

	template <typename T>
	struct __libcpp_is_nothrow_destructible<false, T>: public false_type {};

	template <typename T>
	struct __libcpp_is_nothrow_destructible<true, T>: public integral_constant<bool, noexcept(std::declval<T>().~T()) > {};

	template <typename T>
	struct is_nothrow_destructible: public __libcpp_is_nothrow_destructible<is_destructible<T>::value, T> {};

	template <typename T, size_t N>
	struct is_nothrow_destructible<T[N]>: public is_nothrow_destructible<T> {};

	template <typename T>
	struct is_nothrow_destructible<T&>: public true_type {};

	template <typename T>
	struct is_nothrow_destructible<T &&>: public true_type {};

	template <typename T>
	constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;

	template <typename ForwardIterator1, typename ForwardIterator2>
	inline constexpr
	ForwardIterator2
	swap_ranges(ForwardIterator1 __first1, ForwardIterator1 __last1, ForwardIterator2 __first2);

	template <typename T>
	inline typename enable_if<is_move_constructible<T>::value && is_move_assignable<T>::value>::type constexpr
	swap(T &__x, T &__y) noexcept(is_nothrow_move_constructible<T>::value && is_nothrow_move_assignable<T>::value) {
		T __t(std::move(__x));
		__x = std::move(__y);
		__y = std::move(__t);
	}

	template<typename T, size_t N>
	inline constexpr typename enable_if<__is_swappable<T>::value>::type
	swap(T (&__a)[N], T (&__b)[N]) noexcept(__is_nothrow_swappable<T>::value) {
		std::swap_ranges(__a, __a + N, __b);
	}

	template <typename ForwardIterator1, typename ForwardIterator2>
	inline constexpr ForwardIterator2
	swap_ranges(ForwardIterator1 __first1, ForwardIterator1 __last1, ForwardIterator2 __first2) {
		for(; __first1 != __last1; ++__first1, (void) ++__first2)
			swap(*__first1, *__first2);
		return __first2;
	}

	template <typename ForwardIterator1, typename ForwardIterator2>
	inline constexpr void
	iter_swap(ForwardIterator1 __a, ForwardIterator2 __b) noexcept(noexcept(swap(*std::declval<ForwardIterator1>(), *std::declval<ForwardIterator2>()))) {
		swap(*__a, *__b);
	}

#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
	template <typename T, typename U>
	struct is_convertible: public integral_constant<bool, __is_convertible_to(T, U)> {};
#else
	namespace __is_convertible_imp {
		template <typename T>
		void __test_convert(T);

		template <typename From, typename To, typename = void>
		struct __is_convertible_test: public false_type {};

		template <typename From, typename To>
		struct __is_convertible_test<From, To, decltype(std::__is_convertible_imp::__test_convert<To>(std::declval<From>()))>: public true_type {};

		template <typename T, bool _IsArray = is_array<T>::value, bool _IsFunction = is_function<T>::value, bool _IsVoid = is_void<T>::value>
		struct __is_array_function_or_void {
			enum {value = 0};
		};

		template <typename T>
		struct __is_array_function_or_void<T, true, false, false> {enum {value = 1};};

		template <typename T>
		struct __is_array_function_or_void<T, false, true, false> {enum {value = 2};};

		template <typename T>
		struct __is_array_function_or_void<T, false, false, true> {enum {value = 3};};
	}

	template <typename T, unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<T>::type>::value>
	struct __is_convertible_check {
		static const size_t __v = 0;
	};

	template <typename T>
	struct __is_convertible_check<T, 0> {
		static const size_t __v = sizeof(T);
	};

	template <typename _T1, typename _T2,
		unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
		unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
	struct __is_convertible: public integral_constant<bool, __is_convertible_imp::__is_convertible_test<_T1, _T2>::value> {};

	template <typename T1, typename T2> struct __is_convertible<T1, T2, 0, 1> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 1, 1> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 2, 1> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 3, 1> : public false_type {};

	template <typename T1, typename T2> struct __is_convertible<T1, T2, 0, 2> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 1, 2> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 2, 2> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 3, 2> : public false_type {};

	template <typename T1, typename T2> struct __is_convertible<T1, T2, 0, 3> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 1, 3> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 2, 3> : public false_type {};
	template <typename T1, typename T2> struct __is_convertible<T1, T2, 3, 3> : public true_type {};

	template <typename T1, typename T2>
	struct is_convertible: public __is_convertible<T1, T2> {
		static const size_t __complete_check1 = __is_convertible_check<T1>::__v;
		static const size_t __complete_check2 = __is_convertible_check<T2>::__v;
	};
#endif

	template <typename _From, typename _To>
	constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
}

#undef _INLINE
