#pragma once

#include "cstddef"

// Based on code from the LLVM project (https://llvm.org).

#define _INLINE inline __attribute__((__always_inline__))

namespace std {
	struct __two {
		char __lx[2];
	};

	template <typename T, T v>
	struct integral_constant {
		static constexpr const T value = v;
		typedef T value_type;
		typedef integral_constant type;
		
		constexpr operator value_type() const noexcept {
			return value;
		}

		constexpr value_type operator()() const noexcept {
			return value;
		}
	};

	typedef integral_constant<bool, true> true_type;
	typedef integral_constant<bool, false> false_type;

	template <bool B>
	using bool_constant = integral_constant<bool, B>;

	template <typename T>
	struct __libcpp_is_final: public integral_constant<bool, __is_final(T)> {};
	template <typename T>
	struct is_final: public integral_constant<bool, __is_final(T)> {};
	template <typename T>
	constexpr bool is_final_v = is_final<T>::value;

	template <typename T>
	struct is_empty: public integral_constant<bool, __is_empty(T)> {};
	template <typename T>
	constexpr bool is_empty_v = is_empty<T>::value;

	template <bool, typename T = void>
	struct enable_if {};
	template <bool B, typename T = void>
	using enable_if_t = typename enable_if<B, T>::type;

	template <typename T, typename U>
	struct is_same: public false_type {};
	template <typename T>
	struct is_same<T, T>: public true_type {};

	template <typename T>
	struct is_array: public false_type {};
	template <typename T>
	struct is_array<T[]>: public true_type {};
	template <typename T, size_t N>
	struct is_array<T[N]>: public true_type {};

	template <typename T>
	struct is_lvalue_reference: public false_type {};
	template <typename T>
	struct is_lvalue_reference<T &>: public true_type {};

	template <typename T>
	struct is_rvalue_reference: public false_type {};
	template <typename T>
	struct is_rvalue_reference<T &&>: public true_type {};

	template <typename T>
	struct is_reference: public false_type {};
	template <typename T>
	struct is_reference<T &>: public true_type {};
	template <typename T>
	struct is_reference<T &&>: public true_type {};

	template <typename T>
	inline constexpr bool is_reference_v = is_reference<T>::value;
	template <typename T>
	inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
	template <typename T>
	inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

	template <typename T>
	struct is_const: public false_type {};
	template <typename T>
	struct is_const<T const>: public true_type {};
	template <typename T>
	inline constexpr bool is_const_v = is_const<T>::value;

	template <typename T>
	struct is_function: public bool_constant<!(is_reference_v<T> || is_const_v<const T>)> {};

	struct __is_referenceable_impl {
		template <typename T> static T & __test(int);
		template <typename T> static __two __test(...);
	};

	template <bool B>
	using _BoolConstant = integral_constant<bool, B>;

	template <typename T, typename U>
	using _IsSame = _BoolConstant<is_same<T, U>::value>;

	template <typename T, typename U>
	using _IsNotSame = _BoolConstant<!is_same<T, U>::value>;

	template <class T>
	struct __is_referenceable: integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<T>(0)), __two>::value> {};

	template <typename T>
	struct remove_const {
		typedef T type;
	};

	template <typename T>
	struct remove_const<const T> {
		typedef T type;
	};

	template <typename T>
	using remove_const_t = typename remove_const<T>::type;

	template <typename T>
	struct remove_volatile {
		typedef T type;
	};

	template<typename T>
	struct remove_volatile<volatile T> {
		typedef T type;
	};

	template <typename T>
	using remove_volatile_t = typename remove_volatile<T>::type;

	template <typename T>
	struct remove_cv {
		typedef typename remove_volatile<typename remove_const<T>::type>::type type;
	};

	template <typename T>
	using remove_cv_t = typename remove_cv<T>::type;

	template <bool B, typename If, typename Then>
	struct conditional {
		typedef If type;
	};

	template <typename If, typename Then>
	struct conditional<false, If, Then> {
		typedef Then type;
	};

	template <bool B, typename If, typename Then>
	using conditional_t = typename conditional<B, If, Then>::type;

	template <typename T>
	struct remove_reference {
		typedef T type;
	};

	template <typename T>
	struct remove_reference<T &> {
		typedef T type;
	};

	template <typename T>
	struct remove_reference<T &&> {
		typedef T type;
	};

	template <typename T>
	struct remove_extent {
		typedef T type;
	};

	template <typename T>
	struct remove_extent<T[]> {
		typedef T type;
	};

	template <typename T, size_t N>
	struct remove_extent<T[N]> {
		typedef T type;
	};

	template <typename T, bool = __is_referenceable<T>::value || _IsSame<typename remove_cv<T>::type, void>::value>
	struct __add_pointer_impl {
		typedef typename remove_reference<T>::type * type;
	};

	template <typename T>
	struct __add_pointer_impl<T, false> {
		typedef T type;
	};

	template <typename T>
	struct add_pointer {
		typedef typename __add_pointer_impl<T>::type type;
	};

	template <typename U, bool>
	struct __decay {
		typedef typename remove_cv<U>::type type;
	};

	template <typename U>
	struct __decay<U, true> {
		public:
			typedef typename conditional<is_array<U>::value, typename remove_extent<U>::type *, typename conditional<is_function<U>::value, typename add_pointer<U>::type, typename remove_cv<U>::type>::type>::type type;
	};

	template <typename T>
	struct decay {
		private:
			typedef typename remove_reference<T>::type U;
		
		public:
			typedef typename __decay<U, __is_referenceable<U>::value>::type type;
	};

	template <typename T>
	using decay_t = typename decay<T>::type;

	template <typename T>
	_INLINE constexpr T && forward(typename remove_reference<T>::type &t) noexcept {
		return static_cast<T &&>(t);
	}

	template <typename T>
	_INLINE constexpr T && forward(typename remove_reference<T>::type &&t) noexcept {
		static_assert(!is_lvalue_reference<T>::value, "cannot forward an rvalue as an lvalue");
		return static_cast<T &&>(t);
	}
}

#undef _INLINE
