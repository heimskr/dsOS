#pragma once

#include "lib/printf.h"
#include "lib/string.h"
#include "lib/swap.h"
#include "memory/Memory.h"
#include "memory/memset.h"
#include "iterator"

// #define _STRING_CHECK_LENGTH(n) do { if ((n)) throw std::out_of_range("basic_string"); } while(0)
#define _STRING_CHECK_LENGTH(n)

namespace std {
	template <typename value_type>
	class basic_string {
		private:
			static constexpr size_t min_size = 24;
			value_type *_str;
			/** Doesn't include a terminating null character. */
			size_t _size; 
			/** Doesn't include a terminating null character. */
			size_t _capacity;

		public:
			using reference = value_type &;
			using const_reference = const value_type &;
			using pointer = value_type *;
			using const_pointer = const value_type *;
			using difference_type = ptrdiff_t;

			class const_iterator {
				friend class basic_string<value_type>;

				protected:
					basic_string *parent;
					size_t pos;
					constexpr const_iterator(basic_string<value_type> &parent_): const_iterator(parent_, 0) {}
					constexpr const_iterator(basic_string<value_type> &parent_, size_t pos_): parent(&parent_), pos(pos_) {}

				public:
					constexpr const_iterator operator++(int) const {
						return iterator(*parent, pos + 1);
					}

					constexpr const_iterator & operator++() {
						++pos;
						return *this;
					}

					constexpr const_iterator operator--(int) const {
						return const_iterator(*parent, pos - 1);
					}

					constexpr const_iterator & operator--() {
						--pos;
						return *this;
					}

					constexpr const_iterator & operator+=(difference_type offset) {
						pos += offset;
						return *this;
					}

					constexpr const_iterator & operator-=(difference_type offset) {
						pos -= offset;
						return *this;
					}

					constexpr const value_type & operator*() const {
						return (*parent)[pos];
					}

					constexpr const value_type * operator->() const {
						return &(*parent)[pos];
					}

					constexpr const_iterator operator+(difference_type offset) const {
						return const_iterator(*parent, pos + offset);
					}

					constexpr const_iterator operator-(difference_type offset) const {
						return const_iterator(*parent, pos - offset);
					}

					constexpr difference_type operator-(const_iterator other) const {
						return pos - other.pos;
					}

					constexpr const value_type & operator[](difference_type offset) const {
						return (*parent)[pos + offset];
					}

					constexpr bool operator==(const_iterator other) const { return parent == other.parent && pos == other.pos; }
					constexpr bool operator!=(const_iterator other) const { return parent != other.parent || pos != other.pos; }
					constexpr bool operator< (const_iterator other) const { return parent == other.parent && pos <  other.pos; }
					constexpr bool operator> (const_iterator other) const { return parent == other.parent && pos >  other.pos; }
					constexpr bool operator<=(const_iterator other) const { return parent == other.parent && pos <= other.pos; }
					constexpr bool operator>=(const_iterator other) const { return parent == other.parent && pos >= other.pos; }
			};

			class iterator {
				friend class basic_string<value_type>;

				protected:
					basic_string *parent;
					size_t pos;
					constexpr iterator(basic_string<value_type> &parent_): iterator(parent_, 0) {}
					constexpr iterator(basic_string<value_type> &parent_, size_t pos_): parent(&parent_), pos(pos_) {}

				public:
					constexpr iterator operator++(int) const {
						return iterator(*parent, pos + 1);
					}

					constexpr iterator & operator++() {
						++pos;
						return *this;
					}

					constexpr iterator operator--(int) const {
						return iterator(*parent, pos - 1);
					}

					constexpr iterator & operator--() {
						--pos;
						return *this;
					}

					constexpr iterator & operator+=(difference_type offset) {
						pos += offset;
						return *this;
					}

					constexpr iterator & operator-=(difference_type offset) {
						pos -= offset;
						return *this;
					}

					constexpr value_type & operator*() {
						return (*parent)[pos];
					}

					constexpr const value_type & operator*() const {
						return (*parent)[pos];
					}

					constexpr value_type * operator->() {
						return &(*parent)[pos];
					}

					constexpr const value_type * operator->() const {
						return &(*parent)[pos];
					}

					constexpr iterator operator+(difference_type offset) const {
						return iterator(*parent, pos + offset);
					}

					constexpr iterator operator-(difference_type offset) const {
						return iterator(*parent, pos - offset);
					}

					constexpr difference_type operator-(iterator other) const {
						return pos - other.pos;
					}

					constexpr value_type & operator[](difference_type offset) {
						return (*parent)[pos + offset];
					}

					constexpr const value_type & operator[](difference_type offset) const {
						return (*parent)[pos + offset];
					}

					constexpr bool operator==(iterator other) const { return parent == other.parent && pos == other.pos; }
					constexpr bool operator!=(iterator other) const { return parent != other.parent || pos != other.pos; }
					constexpr bool operator< (iterator other) const { return parent == other.parent && pos <  other.pos; }
					constexpr bool operator> (iterator other) const { return parent == other.parent && pos >  other.pos; }
					constexpr bool operator<=(iterator other) const { return parent == other.parent && pos <= other.pos; }
					constexpr bool operator>=(iterator other) const { return parent == other.parent && pos >= other.pos; }

					constexpr operator const_iterator() const {
						return const_iterator(*parent, pos);
					}
			};

			class const_reverse_iterator {
				friend class basic_string<value_type>;

				protected:
					basic_string *parent;
					size_t pos;
					constexpr const_reverse_iterator(basic_string<value_type> &parent_): const_reverse_iterator(parent_, 0) {}
					constexpr const_reverse_iterator(basic_string<value_type> &parent_, size_t pos_): parent(&parent_), pos(pos_) {}

				public:
					constexpr const_reverse_iterator operator++(int) const {
						return const_reverse_iterator(*parent, pos + 1);
					}

					constexpr const_reverse_iterator & operator++() {
						++pos;
						return *this;
					}

					constexpr const_reverse_iterator operator--(int) const {
						return const_reverse_iterator(*parent, pos - 1);
					}

					constexpr const_reverse_iterator & operator--() {
						--pos;
						return *this;
					}

					constexpr const_reverse_iterator & operator+=(difference_type offset) {
						pos += offset;
						return *this;
					}

					constexpr const_reverse_iterator & operator-=(difference_type offset) {
						pos -= offset;
						return *this;
					}

					constexpr const value_type & operator*() const {
						return (*parent)[parent->_size - 1 - pos];
					}

					constexpr const value_type * operator->() const {
						return &(*parent)[parent->_size - 1 - pos];
					}

					constexpr const_reverse_iterator operator+(difference_type offset) const {
						return const_reverse_iterator(*parent, pos + offset);
					}

					constexpr const_reverse_iterator operator-(difference_type offset) const {
						return const_reverse_iterator(*parent, pos - offset);
					}

					constexpr difference_type operator-(const_reverse_iterator other) const {
						// TODO: verify
						return pos - other.pos;
					}

					constexpr const value_type & operator[](difference_type offset) const {
						return (*parent)[pos + offset];
					}

					// TODO: verify these
					constexpr bool operator==(const_reverse_iterator other) const { return parent == other.parent && pos == other.pos; }
					constexpr bool operator!=(const_reverse_iterator other) const { return parent != other.parent || pos != other.pos; }
					constexpr bool operator< (const_reverse_iterator other) const { return parent == other.parent && pos <  other.pos; }
					constexpr bool operator> (const_reverse_iterator other) const { return parent == other.parent && pos >  other.pos; }
					constexpr bool operator<=(const_reverse_iterator other) const { return parent == other.parent && pos <= other.pos; }
					constexpr bool operator>=(const_reverse_iterator other) const { return parent == other.parent && pos >= other.pos; }
			};

			class reverse_iterator {
				friend class basic_string<value_type>;

				protected:
					basic_string *parent;
					size_t pos;
					constexpr reverse_iterator(basic_string<value_type> &parent_): reverse_iterator(parent_, 0) {}
					constexpr reverse_iterator(basic_string<value_type> &parent_, size_t pos_): parent(&parent_), pos(pos_) {}

				public:
					constexpr reverse_iterator operator++(int) const {
						return reverse_iterator(*parent, pos + 1);
					}

					constexpr reverse_iterator & operator++() {
						++pos;
						return *this;
					}

					constexpr reverse_iterator operator--(int) const {
						return reverse_iterator(*parent, pos - 1);
					}

					constexpr reverse_iterator & operator--() {
						--pos;
						return *this;
					}

					constexpr reverse_iterator & operator+=(difference_type offset) {
						pos += offset;
						return *this;
					}

					constexpr reverse_iterator & operator-=(difference_type offset) {
						pos -= offset;
						return *this;
					}

					constexpr value_type & operator*() {
						return (*parent)[parent->_size - 1 - pos];
					}

					constexpr const value_type & operator*() const {
						return (*parent)[parent->_size - 1 - pos];
					}

					constexpr value_type * operator->() {
						return &(*parent)[parent->_size - 1 - pos];
					}

					constexpr const value_type * operator->() const {
						return &(*parent)[parent->_size - 1 - pos];
					}

					constexpr reverse_iterator operator+(difference_type offset) const {
						return reverse_iterator(*parent, pos + offset);
					}

					constexpr reverse_iterator operator-(difference_type offset) const {
						return reverse_iterator(*parent, pos - offset);
					}

					constexpr difference_type operator-(reverse_iterator other) const {
						// TODO: verify
						return pos - other.pos;
					}

					constexpr value_type & operator[](difference_type offset) {
						return (*parent)[pos + offset];
					}

					constexpr const value_type & operator[](difference_type offset) const {
						return (*parent)[pos + offset];
					}

					constexpr operator const_reverse_iterator() const {
						return const_reverse_iterator(*parent, pos);
					}

					// TODO: verify these
					constexpr bool operator==(reverse_iterator other) const { return parent == other.parent && pos == other.pos; }
					constexpr bool operator!=(reverse_iterator other) const { return parent != other.parent || pos != other.pos; }
					constexpr bool operator< (reverse_iterator other) const { return parent == other.parent && pos <  other.pos; }
					constexpr bool operator> (reverse_iterator other) const { return parent == other.parent && pos >  other.pos; }
					constexpr bool operator<=(reverse_iterator other) const { return parent == other.parent && pos <= other.pos; }
					constexpr bool operator>=(reverse_iterator other) const { return parent == other.parent && pos >= other.pos; }
			};

			static constexpr size_t npos = -1;

			basic_string() {
				_size = 0;
				_capacity = min_size;
				_str = new value_type[_capacity + 1];
			}

			basic_string(const value_type *src) {
				_size = _capacity = strlen(src);
				_str = new value_type[_size + 1];
				strcpy(_str, src);
			}

			iterator begin() { return {*this}; }
			iterator   end() { return {*this, _size}; }
			reverse_iterator rbegin() { return {*this}; }
			reverse_iterator   rend() { return {*this, _size}; }
			const_iterator   cbegin() { return {*this}; }
			const_iterator     cend() { return {*this, _size}; }
			const_reverse_iterator crbegin() { return {*this}; }
			const_reverse_iterator   crend() { return {*this, _size}; }

			const value_type * c_str() const {
				return _str;
			}

			size_t size() const {
				return _size;
			}

			size_t length() const {
				return _size;
			}

			size_t max_size() const {
				return -1; // Not quite true...
			}

			size_t capacity() const {
				return _capacity;
			}

			void resize(size_t n, value_type c = '\0') {
				value_type *new_str = new value_type[n + 1];
				strncpy(new_str, _str, n + 1);
				delete[] _str;
				_str = new_str;
				if (_capacity < n)
					memset(new_str + _capacity, c, n - _capacity);
				_capacity = n;
			}

			void reserve(size_t n = 0) {
				if (_capacity < n)
					resize(n, '\0');
			}

			void clear() {
				delete[] _str;
				_capacity = min_size;
				_str = new value_type[_capacity + 1];
				_size = 0;
			}

			bool empty() const {
				return _size == 0;
			}

			void shrink_to_fit() {
				if (_size < _capacity + 1)
					resize(_size, '\0');
			}

			value_type & operator[](size_t pos) {
				return _str[pos];
			}

			const value_type & operator[](size_t pos) const {
				return _str[pos];
			}

			value_type & at(size_t pos) {
				_STRING_CHECK_LENGTH(_size < pos);
				return _str[pos];
			}

			const value_type & at(size_t pos) const {
				_STRING_CHECK_LENGTH(_size < pos);
				return _str[pos];
			}

			value_type & back() {
				_STRING_CHECK_LENGTH(empty());
				return _str[_size];
			}

			const value_type & back() const {
				_STRING_CHECK_LENGTH(empty());
				return _str[_size];
			}

			value_type & front() {
				_STRING_CHECK_LENGTH(empty());
				return _str[0];
			}

			const value_type & front() const {
				_STRING_CHECK_LENGTH(empty());
				return _str[0];
			}

			basic_string<value_type> & operator+=(const basic_string<value_type> &other) {
				reserve(_size + other._size);
				for (size_t i = 0; i <= other._size; ++i)
					_str[i + _size] = other._str[i];
				_str[_size + other._size + 1] = '\0';
				_size += other._size;
				return *this;
			}

			basic_string<value_type> & operator+=(const value_type *other) {
				const size_t other_size = strlen(other);
				reserve(_size + other_size);
				for (size_t i = 0; i <= other_size; ++i)
					_str[i + _size] = other[i];
				_str[_size + other_size + 1] = '\0';
				_size += other_size;
				return *this;
			}

			basic_string<value_type> & operator+=(value_type ch) {
				reserve(_size + 1);
				_str[_size] = ch;
				_str[_size + 1] = '\0';
				++_size;
				return *this;
			}

			basic_string<value_type> & append(const basic_string<value_type> &other) {
				return *this += other;
			}

			basic_string<value_type> & append(const basic_string<value_type> &other, size_t subpos, size_t sublen) {
				reserve(_size + sublen);
				for (size_t i = 0; i < sublen; ++i)
					_str[_size + i] = other[subpos + i];
				_size += sublen;
				return *this;
			}

			basic_string<value_type> & append(const value_type *other) {
				return *this += other;
			}

			basic_string<value_type> & append(const value_type *other, size_t subpos, size_t sublen) {
				reserve(_size + sublen);
				for (size_t i = 0; i < sublen; ++i)
					_str[_size + i] = other[subpos + i];
				_size += sublen;
				return *this;
			}

			basic_string<value_type> & append(size_t n, value_type ch) {
				reserve(_size + n);
				memset(_str + _size, ch, n);
				_size += n;
				return *this;
			}

			template <class InputIterator>
			basic_string<value_type> & append(InputIterator first, InputIterator last) {
				size_t to_add = 0;
				for (InputIterator iter = first; iter != last; ++iter)
					++to_add;
				reserve(_size + to_add);
				size_t i = 0;
				for (InputIterator iter = first; iter != last; ++iter)
					_str[_size + i++] = *iter;
				return *this;
			}

			void push_back(value_type ch) {
				*this += ch;
			}

			basic_string<value_type> & insert(size_t pos, const basic_string<value_type> &other) {
				reserve(_size + other._size);
				// for (size_t i = 0; i < _size - pos; ++i)
				for (size_t i = _size - pos - 1;; --i) {
					_str[pos + other._size + i] = _str[pos + i];
					if (i == 0)
						break;
				}
				for (size_t i = 0; i < other._size; ++i)
					_str[pos + i] = other._str[i];
				_size += other._size;
				return *this;
			}

			basic_string<value_type> & insert(size_t pos, const basic_string<value_type> &other, size_t subpos, size_t sublen) {
				reserve(_size + sublen);
				for (size_t i = _size - pos - 1;; --i) {
					_str[pos + sublen + i] = _str[pos + i];
					if (i == 0)
						break;
				}
				for (size_t i = 0; i < sublen; ++i)
					_str[pos + i] = other._str[subpos + i];
				_size += sublen;
				return *this;
			}

			basic_string<value_type> & insert(size_t pos, const value_type *other) {
				const size_t other_size = strlen(other);
				reserve(_size + other_size);
				for (size_t i = _size - pos - 1;; --i) {
					_str[pos + other_size + i] = _str[pos + i];
					if (i == 0)
						break;
				}
				for (size_t i = 0; i < other_size; ++i)
					_str[pos + i] = other[i];
				_size += other_size;
				return *this;
			}

			basic_string<value_type> & insert(size_t pos, const value_type *other, size_t n) {
				reserve(_size + n);
				for (size_t i = _size - pos - 1;; --i) {
					_str[pos + n + i] = _str[pos + i];
					if (i == 0)
						break;
				}
				for (size_t i = 0; i < n; ++i)
					_str[pos + i] = other[i];
				_size += n;
				return *this;
			}

			basic_string<value_type> & insert(size_t pos, size_t n, value_type ch) {
				reserve(_size + n);
				for (size_t i = _size - pos - 1;; --i) {
					_str[pos + n + i] = _str[pos + i];
					if (i == 0)
						break;
				}
				for (size_t i = 0; i < n; ++i)
					_str[pos + i] = ch;
				return *this;
			}

			void insert(iterator p, size_t n, value_type ch) {
				insert(p.pos, n, ch);
			}

			iterator insert(iterator p, value_type ch) {
				insert(p, 1, ch);
				return p;
			}

			template <class InputIterator>
			void insert(iterator p, InputIterator first, InputIterator last) {
				size_t to_add = 0;
				for (InputIterator iter = first; iter != last; ++iter)
					++to_add;
				reserve(_size + to_add);
				for (size_t i = to_add - 1;; --i) {
					_str[p.pos + to_add + i] = _str[p.pos + i];
					if (i == 0)
						break;
				}
				for (InputIterator iter = first; iter != last; ++iter)
					_str[(p++).pos] = *iter;
				_size += to_add;
			}

			basic_string<value_type> & erase(size_t pos = 0, size_t len = npos) {
				if (len == npos) {
					_size = pos;
				} else {
					for (size_t i = 0; i < len; ++i)
						_str[pos + i] = _str[pos + len + i];
					_size -= len;
				}
				return *this;
			}

			iterator erase(iterator p) {
				erase(p.pos, 1);
				return p;
			}

			iterator erase(iterator first, iterator last) {
				erase(first.pos, last - first);
				return first;
			}

			basic_string<value_type> & replace(size_t pos, size_t len, const basic_string<value_type> &other) {
				reserve(_size + other._size - len);
				if (other._size < len)
					for (size_t i = pos; i < _size + other._size - len; ++i)
						_str[i] = _str[i + len - other._size];
				else
					for (size_t i = _size - len - 1;; --i) {
						_str[pos + other._size + i - 1] = _str[pos + i];
						if (i == 0)
							break;
					}
				for (size_t i = 0; i < other._size; ++i)
					_str[pos + i] = other._str[i];
				_size += other._size;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			basic_string<value_type> & replace(const_iterator i1, const_iterator i2, const basic_string<value_type> &other) {
				return replace(i1.pos, i2 - i1);
			}

			basic_string<value_type> & replace(size_t pos, size_t len, const basic_string<value_type> &other, size_t subpos, size_t sublen = npos) {
				if (other._size - subpos < sublen)
					sublen = other._size - subpos;
				reserve(_size + sublen - len);
				if (sublen < len)
					for (size_t i = pos + sublen; i < _size + sublen - len; ++i)
						_str[i] = _str[i + len - sublen];
				else
					for (size_t i = _size + sublen - len - 1;; --i) {
						_str[i] = _str[i + len - sublen];
						if (i == pos + sublen)
							break;
					}
				for (size_t i = 0; i < sublen; ++i)
					_str[pos + i] = other._str[i + subpos];
				_size += sublen;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			basic_string<value_type> & replace(size_t pos, size_t len, const value_type *other) {
				const size_t other_size = strlen(other);
				reserve(_size + other_size - len);
				if (other_size < len)
					for (size_t i = pos; i < _size + other_size - len; ++i)
						_str[i] = _str[i + len - other_size];
				else
					for (size_t i = _size - len - 1;; --i) {
						_str[pos + other_size + i - 1] = _str[pos + i];
						if (i == 0)
							break;
					}
				for (size_t i = 0; i < other_size; ++i)
					_str[pos + i] = other[i];
				_size += other_size;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			basic_string<value_type> & replace(const_iterator i1, const_iterator i2, const value_type *other) {
				return replace(i1.pos, i2 - i1, other);
			}

			basic_string<value_type> & replace(size_t pos, size_t len, const value_type *other, size_t n) {
				reserve(_size + n - len);
				if (n < len)
					for (size_t i = pos; i < _size + n - len; ++i)
						_str[i] = _str[i + len - n];
				else
					for (size_t i = _size - len - 1;; --i) {
						_str[pos + n + i - 1] = _str[pos + i];
						if (i == 0)
							break;
					}
				for (size_t i = 0; i < n; ++i)
					_str[pos + i] = other[i];
				_size += n;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			basic_string<value_type> & replace(const_iterator i1, const_iterator i2, const value_type *other, size_t n) {
				return replace(i1.pos, i2 - i1, other, n);
			}

			basic_string<value_type> & replace(size_t pos, size_t len, size_t n, char ch) {
				reserve(_size + n - len);
				if (n < len)
					for (size_t i = pos + n; i < _size + n - len; ++i)
						_str[i] = _str[i + len - n];
				else
					for (size_t i = _size + n - len - 1;; --i) {
						_str[i] = _str[i - n + len];
						if (i == pos + n)
							break;
					}
				for (size_t i = 0; i < n; ++i)
					_str[pos + i] = ch;
				_size += n;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			basic_string<value_type> & replace(const_iterator i1, const_iterator i2, size_t n, char ch) {
				return replace(i1.pos, i2 - i1, n, ch);
			}

			template <class InputIterator>
			basic_string<value_type> & replace(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last) {
				size_t to_add = 0;
				for (InputIterator iter = first; iter != last; ++iter)
					++to_add;
				const size_t len = i2 - i1;
				reserve(_size + to_add - len);
				if (to_add < len)
					for (size_t i = i1.pos; i < _size + to_add - len; ++i)
						_str[i] = _str[i + len - to_add];
				else
					for (size_t i = _size - len - 1;; --i) {
						_str[i1.pos + len + i - 1] = _str[i1.pos + i];
						if (i == 0)
							break;
					}
				for (size_t i = i1.pos; first != last; ++first)
					_str[i++] = *first;
				_size += to_add;
				_size -= len;
				_str[_size] = '\0';
				return *this;
			}

			void swap(basic_string<value_type> &other) {
				swap(_str, other._str);
				swap(_size, other._size);
				swap(_capacity, other._capacity);
			}
	};

	using string = basic_string<char>;
}

#undef _STRING_CHECK_LENGTH
